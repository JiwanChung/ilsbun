{"version":3,"sources":["meteor://ðŸ’»app/packages/tap_i18n-db/packages/tap_i18n-db.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/tap_i18n-db.js","sourcesContent":["(function () {\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                               //\n// packages/tap:i18n-db/globals.js                                                                               //\n//                                                                                                               //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                 //\n// The globals object will be accessible to the build plugin, the server and                                     // 1\n// the client                                                                                                    // 2\n                                                                                                                 // 3\nglobals = {                                                                                                      // 4\n  fallback_language: \"en\"                                                                                        // 5\n};                                                                                                               // 6\n                                                                                                                 // 7\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                               //\n// packages/tap:i18n-db/tap_i18n_db-common.coffee.js                                                             //\n//                                                                                                               //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                 //\n__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nvar commonCollectionExtensions, removeTrailingUndefs,\n  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\nTAPi18n.Collection = function(name, options) {\n  var collection, original_transform;\n  if (options == null) {\n    options = {};\n  }\n  if (Meteor.isClient) {\n    original_transform = options.transform || function(doc) {\n      return doc;\n    };\n    options.transform = function(doc) {\n      return share.i18nCollectionTransform(original_transform(doc), collection);\n    };\n  }\n  collection = share.i18nCollectionExtensions(commonCollectionExtensions(new Meteor.Collection(name, options)));\n  if (Meteor.isClient) {\n    if (Package[\"yogiben:admin\"] != null) {\n      collection._disableTransformationOnRoute(/^\\/admin(\\/?$|\\/)/);\n    }\n  }\n  collection._base_language = \"base_language\" in options ? options[\"base_language\"] : globals.fallback_language;\n  return collection;\n};\n\nshare.helpers = {};\n\nshare.helpers.dialectOf = function(lang) {\n  if ((lang != null) && __indexOf.call(lang, \"-\") >= 0) {\n    return lang.replace(/-.*/, \"\");\n  }\n  return null;\n};\n\nshare.helpers.removeTrailingUndefs = function(arr) {\n  while ((!_.isEmpty(arr)) && (_.isUndefined(_.last(arr)))) {\n    arr.pop();\n  }\n  return arr;\n};\n\nremoveTrailingUndefs = share.helpers.removeTrailingUndefs;\n\ncommonCollectionExtensions = function(obj) {\n  var getLanguageOrEnvLanguage, isSupportedLanguage, reportError, throwError, verifyI18nEnabled;\n  reportError = function(error, attempted_operation, callback) {\n    if (_.isFunction(callback)) {\n      Meteor.setTimeout((function() {\n        return callback(error, false);\n      }), 0);\n    } else {\n      console.log(\"\" + attempted_operation + \" failed: \" + error.reason);\n    }\n    return error;\n  };\n  throwError = function(error, attempted_operation, callback) {\n    throw reportError(error, attempted_operation, callback);\n  };\n  verifyI18nEnabled = function(attempted_operation, callback) {\n    if (TAPi18n._enabled()) {\n      return;\n    }\n    return throwError(new Meteor.Error(400, \"TAPi18n is not supported\"), attempted_operation, callback);\n  };\n  isSupportedLanguage = function(lang, attempted_operation, callback) {\n    if (__indexOf.call(TAPi18n.conf.supported_languages, lang) >= 0) {\n      return;\n    }\n    return throwError(new Meteor.Error(400, \"Not supported language: \" + lang), attempted_operation, callback);\n  };\n  getLanguageOrEnvLanguage = function(language_tag, attempted_operation, callback) {\n    if (Meteor.isClient) {\n      if (language_tag == null) {\n        language_tag = TAPi18n.getLanguage();\n      }\n    }\n    if (language_tag != null) {\n      return language_tag;\n    }\n    return throwError(new Meteor.Error(400, \"Missing language_tag\"), attempted_operation, callback);\n  };\n  obj.insertTranslations = function(doc, translations, callback) {\n    var lang;\n    try {\n      verifyI18nEnabled(\"insert\", callback);\n    } catch (_error) {\n      return null;\n    }\n    doc = _.extend({}, doc);\n    translations = _.extend({}, translations);\n    if (translations != null) {\n      for (lang in translations) {\n        try {\n          isSupportedLanguage(lang, \"insert\", callback);\n        } catch (_error) {\n          return null;\n        }\n        if (lang === this._base_language) {\n          doc = _.extend(doc, translations[lang]);\n          delete translations[lang];\n        }\n      }\n      if (!_.isEmpty(translations)) {\n        doc = _.extend(doc, {\n          i18n: translations\n        });\n      }\n    }\n    return this.insert.apply(this, removeTrailingUndefs([doc, callback]));\n  };\n  obj.updateTranslations = function(selector, translations, options, callback) {\n    var lang, updates;\n    if (_.isFunction(options)) {\n      callback = options;\n      options = void 0;\n    }\n    try {\n      verifyI18nEnabled(\"update\", callback);\n    } catch (_error) {\n      return null;\n    }\n    updates = {};\n    if (translations != null) {\n      for (lang in translations) {\n        try {\n          isSupportedLanguage(lang, \"update\", callback);\n        } catch (_error) {\n          return null;\n        }\n        if (lang === this._base_language) {\n          _.extend(updates, translations[lang]);\n        } else {\n          _.extend(updates, _.object(_.map(translations[lang], (function(val, field) {\n            return [\"i18n.\" + lang + \".\" + field, val];\n          }))));\n        }\n      }\n    }\n    return this.update.apply(this, removeTrailingUndefs([\n      selector, {\n        $set: updates\n      }, options, callback\n    ]));\n  };\n  obj.removeTranslations = function(selector, fields, options, callback) {\n    var field, lang, updates, _i, _len;\n    if (_.isFunction(options)) {\n      callback = options;\n      options = void 0;\n    }\n    try {\n      verifyI18nEnabled(\"remove translations\", callback);\n    } catch (_error) {\n      return null;\n    }\n    if (fields == null) {\n      reportError(new Meteor.Error(400, \"Missing arugment: fields\"), \"remove translations\", callback);\n      return null;\n    }\n    if (!_.isArray(fields)) {\n      reportError(new Meteor.Error(400, \"fields argument should be an array\"), \"remove translations\", callback);\n      return null;\n    }\n    updates = {};\n    for (_i = 0, _len = fields.length; _i < _len; _i++) {\n      field = fields[_i];\n      lang = _.first(field.split(\".\"));\n      try {\n        isSupportedLanguage(lang, \"remove translations\", callback);\n      } catch (_error) {\n        return null;\n      }\n      if (lang === this._base_language) {\n        field = field.replace(\"\" + lang + \".\", \"\");\n        if (field === this._base_language) {\n          reportError(new Meteor.Error(400, \"Complete removal of collection's base language from a document is not permitted\"), \"remove translations\", callback);\n          return null;\n        }\n        updates[field] = \"\";\n      } else {\n        updates[\"i18n.\" + field] = \"\";\n      }\n    }\n    return this.update.apply(this, removeTrailingUndefs([\n      selector, {\n        $unset: updates\n      }, options, callback\n    ]));\n  };\n  obj.insertLanguage = function(doc, translations, language_tag, callback) {\n    var _translations;\n    try {\n      verifyI18nEnabled(\"insert\", callback);\n    } catch (_error) {\n      return null;\n    }\n    if (_.isFunction(language_tag)) {\n      callback = language_tag;\n      language_tag = void 0;\n    }\n    try {\n      language_tag = getLanguageOrEnvLanguage(language_tag, \"insert\", callback);\n    } catch (_error) {\n      return null;\n    }\n    _translations = {};\n    _translations[language_tag] = translations;\n    return this.insertTranslations(doc, _translations, callback);\n  };\n  obj.updateLanguage = function(selector, translations) {\n    var arg, args, callback, language_tag, options, _i, _len, _ref, _translations;\n    try {\n      verifyI18nEnabled(\"update\", callback);\n    } catch (_error) {\n      return null;\n    }\n    language_tag = options = callback = void 0;\n    args = _.toArray(arguments);\n    _ref = args.slice(2);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      arg = _ref[_i];\n      if (_.isFunction(arg)) {\n        callback = arg;\n        break;\n      } else if (_.isObject(arg)) {\n        options = arg;\n      } else if (_.isUndefined(options) && _.isString(arg)) {\n        language_tag = arg;\n      }\n    }\n    try {\n      language_tag = getLanguageOrEnvLanguage(language_tag, \"update\", callback);\n    } catch (_error) {\n      return null;\n    }\n    _translations = {};\n    _translations[language_tag] = translations;\n    return this.updateTranslations(selector, _translations, options, callback);\n  };\n  obj.translate = obj.updateLanguage;\n  obj.removeLanguage = function(selector, fields) {\n    var arg, args, callback, language_tag, options, _fields_to_remove, _i, _len, _ref;\n    try {\n      verifyI18nEnabled(\"remove translations\", callback);\n    } catch (_error) {\n      return null;\n    }\n    language_tag = options = callback = void 0;\n    args = _.toArray(arguments);\n    _ref = args.slice(2);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      arg = _ref[_i];\n      if (_.isFunction(arg)) {\n        callback = arg;\n        break;\n      } else if (_.isObject(arg)) {\n        options = arg;\n      } else if (_.isUndefined(options) && _.isString(arg)) {\n        language_tag = arg;\n      }\n    }\n    try {\n      language_tag = getLanguageOrEnvLanguage(language_tag, \"remove\", callback);\n    } catch (_error) {\n      return null;\n    }\n    if (fields !== null && !_.isArray(fields)) {\n      reportError(new Meteor.Error(400, \"fields argument should be an array\"), \"remove translations\", callback);\n      return null;\n    }\n    if (fields === null) {\n      _fields_to_remove = [\"\" + language_tag];\n    } else {\n      _fields_to_remove = _.map(fields, function(field) {\n        return \"\" + language_tag + \".\" + field;\n      });\n    }\n    return this.removeTranslations(selector, _fields_to_remove, options, callback);\n  };\n  return obj;\n};\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                               //\n// packages/tap:i18n-db/tap_i18n_db-server.coffee.js                                                             //\n//                                                                                                               //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                 //\n__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nvar Fiber,\n  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\nFiber = Npm.require('fibers');\n\nshare.i18nCollectionExtensions = function(obj) {\n  obj.i18nFind = function(selector, options) {\n    var collection_base_language, current_language, dialect_of, field, i18n_fields, lang, original_fields, supported_languages, white_list_projection, _i, _j, _k, _len, _len1, _len2;\n    current_language = Fiber.current.language_tag;\n    if (typeof current_language === \"undefined\") {\n      throw new Meteor.Error(500, \"TAPi18n.i18nFind should be called only from TAPi18n.publish functions\");\n    }\n    if (_.isUndefined(selector)) {\n      selector = {};\n    }\n    dialect_of = share.helpers.dialectOf(current_language);\n    collection_base_language = this._base_language;\n    supported_languages = TAPi18n.conf.supported_languages;\n    if ((current_language != null) && !(__indexOf.call(supported_languages, current_language) >= 0)) {\n      throw new Meteor.Error(400, \"Not supported language\");\n    }\n    if (options == null) {\n      options = {};\n    }\n    original_fields = options.fields || {};\n    i18n_fields = _.extend({}, original_fields);\n    if (!_.isEmpty(i18n_fields)) {\n      delete i18n_fields._id;\n      white_list_projection = _.first(_.values(i18n_fields)) === 1;\n      if (\"_id\" in original_fields) {\n        i18n_fields[\"_id\"] = original_fields[\"_id\"];\n      }\n      if (white_list_projection) {\n        if (lang !== null) {\n          for (_i = 0, _len = supported_languages.length; _i < _len; _i++) {\n            lang = supported_languages[_i];\n            if (lang !== collection_base_language && ((lang === current_language) || (lang === dialect_of))) {\n              for (field in original_fields) {\n                if (field !== \"_id\" && !(__indexOf.call(field, \".\") >= 0)) {\n                  i18n_fields[\"i18n.\" + lang + \".\" + field] = 1;\n                }\n              }\n            }\n          }\n        }\n      } else {\n        if (current_language === null) {\n          i18n_fields.i18n = 0;\n        } else {\n          for (_j = 0, _len1 = supported_languages.length; _j < _len1; _j++) {\n            lang = supported_languages[_j];\n            if (lang !== collection_base_language) {\n              if (lang !== current_language && lang !== dialect_of) {\n                i18n_fields[\"i18n.\" + lang] = 0;\n              } else {\n                for (field in original_fields) {\n                  if (field !== \"_id\" && !(__indexOf.call(field, \".\") >= 0)) {\n                    i18n_fields[\"i18n.\" + lang + \".\" + field] = 0;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    } else {\n      if (current_language === null) {\n        i18n_fields.i18n = 0;\n      } else {\n        for (_k = 0, _len2 = supported_languages.length; _k < _len2; _k++) {\n          lang = supported_languages[_k];\n          if (lang !== collection_base_language && lang !== current_language && lang !== dialect_of) {\n            i18n_fields[\"i18n.\" + lang] = 0;\n          }\n        }\n      }\n    }\n    return this.find(selector, _.extend({}, options, {\n      fields: i18n_fields\n    }));\n  };\n  return obj;\n};\n\nTAPi18n.publish = function(name, handler, options) {\n  var i18n_handler;\n  if (name === null) {\n    throw new Meteor.Error(500, \"TAPi18n.publish doesn't support null publications\");\n  }\n  i18n_handler = function() {\n    var args, cursors, language_tag;\n    args = Array.prototype.slice.call(arguments);\n    language_tag = _.last(args);\n    this.language = language_tag;\n    Fiber.current.language_tag = language_tag;\n    cursors = handler.apply(this, args.slice(0, -1));\n    delete Fiber.current.language_tag;\n    if (cursors != null) {\n      return cursors;\n    }\n  };\n  return Meteor.publish(name, i18n_handler, options);\n};\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}